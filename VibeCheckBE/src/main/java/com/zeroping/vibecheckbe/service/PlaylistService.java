package com.zeroping.vibecheckbe.service;

import com.zeroping.vibecheckbe.dto.PlaylistDTO;
import com.zeroping.vibecheckbe.dto.SavePlaylistToSpotifyRequest;
import com.zeroping.vibecheckbe.dto.SongDTO;
import com.zeroping.vibecheckbe.entity.Playlist;
import com.zeroping.vibecheckbe.entity.Song;
import com.zeroping.vibecheckbe.repository.PlaylistRepository;
import com.zeroping.vibecheckbe.util.SpotifyUriUtil;
import jakarta.transaction.Transactional;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

// Service for managing playlists
@Service
@Transactional
public class PlaylistService {
    private final PlaylistRepository playlistRepository;
    private final SpotifyService spotifyService;

    public PlaylistService(
            PlaylistRepository playlistRepository,
            SpotifyService spotifyService
    ) {
        this.playlistRepository = playlistRepository;
        this.spotifyService = spotifyService;
    }

    // Export playlist to Spotify
    public String savePlaylistToSpotify(UUID userId, SavePlaylistToSpotifyRequest request, String accessToken) {
        // 1. Find the playlist in our DB to get the song list
        Playlist playlist = playlistRepository
                .findByIdAndUserId(request.getPlaylistId(), userId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Playlist not found or does not belong to user"));

        // 2. Extract Spotify URIs
        List<String> trackUris = playlist.getSongs()
                .stream()
                .map(Song::getUrl)                     // 1. Get the HTTP link (https://open...)
                .map(SpotifyUriUtil::urlToUri)         // 2. CONVERT IT to URI (spotify:track:...)
                .filter(uri -> uri != null && !uri.isBlank()) // 3. Remove failures
                .toList();

        if (trackUris.isEmpty()) {
            throw new IllegalStateException("Playlist has no Spotify tracks to export");
        }

        // 3. Get the user's Spotify ID using the token passed from Flutter
        String spotifyUserId = spotifyService.getCurrentUserId(accessToken);

        // 4. Create the empty playlist on Spotify
        String spotifyPlaylistId = spotifyService.createPlaylist(
                accessToken,
                spotifyUserId,
                request.getSpotifyPlaylistName(),
                "Generated by AI via VibeCheck"
        );

        // 5. Add the songs to that new playlist
        spotifyService.addTracksToPlaylist(
                accessToken,
                spotifyPlaylistId,
                trackUris
        );

        // Return the Spotify playlist ID so frontend can embed the player
        return spotifyPlaylistId;

        // Note: We are NOT saving anything back to the database.
        // This avoids the "column exported_to_spotify does not exist" error.
    }

    // Get distinct moods for a user's playlists (up to 3 most recent)
    public List<String> getUserMoods(UUID userId) {
        Pageable topThree = PageRequest.of(0, 3);
        return playlistRepository
                .findDistinctMoodByUserIdOrderByCreatedAtDesc(userId, topThree);
    }

    // Get total number of playlists for a user
    public long getNumberOfPlaylists(UUID userId) {
        return playlistRepository.countByUserId(userId);
    }

    // Get all playlists for a user, ordered by creation date descending
    public List<PlaylistDTO> getUserPlaylists(UUID userId) {
        return playlistRepository.findByUserIdOrderByCreatedAtDesc(userId)
                .stream()
                .map(this::mapToDTO)
                .toList();
    }

    // Get the most recent playlist for a user
    public PlaylistDTO getLastPlaylist(UUID userId) {
        return playlistRepository.findFirstByUserIdOrderByCreatedAtDesc(userId)
                .map(this::mapToDTO)
                .orElse(null);
    }

    // Get the timestamp of the most recent playlist for a user
    public Instant getLastPlaylistTimestamp(UUID userId) {
        return playlistRepository.findLatestTimestamp(userId).orElse(null);
    }

    // Get playlists for a user filtered by mood
    public List<PlaylistDTO> getPlaylistsByMood(UUID userId, String mood) {
        return playlistRepository.findByUserIdAndMood(userId, mood)
                .stream()
                .map(this::mapToDTO)
                .toList();
    }

    // Helper method to map Playlist entity to PlaylistDTO
    private PlaylistDTO mapToDTO(Playlist playlist) {
        PlaylistDTO dto = new PlaylistDTO();
        dto.setId(playlist.getId());
        dto.setName(playlist.getName());
        dto.setMood(playlist.getMood());
        dto.setCreatedAt(playlist.getCreatedAt());
        dto.setUserId(playlist.getUserId());

        if (playlist.getSongs() != null) {
            Set<SongDTO> songs = playlist.getSongs()
                    .stream()
                    .map(this::mapToSongDTO)
                    .collect(Collectors.toSet());
            dto.setSongs(songs);
        }

        return dto;
    }

    // Helper method to map Song entity to SongDTO
    private SongDTO mapToSongDTO(Song song) {
        return new SongDTO(
                song.getId(),
                song.getName(),
                song.getUrl(),
                song.getArtistName()
        );
    }
}