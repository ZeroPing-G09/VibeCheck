@Service
@Transactional
public class PlaylistService {

    private final PlaylistRepository playlistRepository;
    private final UserRepository userRepository;
    private final SpotifyService spotifyService;

    public PlaylistService(
            PlaylistRepository playlistRepository,
            UserRepository userRepository,
            SpotifyService spotifyService
    ) {
        this.playlistRepository = playlistRepository;
        this.userRepository = userRepository;
        this.spotifyService = spotifyService;
    }

    /* =======================
       Spotify export
       ======================= */

    public void savePlaylistToSpotify(UUID userId, SavePlaylistToSpotifyRequest request)
            throws IOException {

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));

        if (user.getSpotifyAccessToken() == null || user.getSpotifyAccessToken().isBlank()) {
            throw new IllegalStateException("User does not have a Spotify access token");
        }

        Playlist playlist = playlistRepository
                .findByIdAndUserId(request.getPlaylistId(), userId)
                .orElseThrow(() ->
                        new IllegalArgumentException("Playlist not found or does not belong to user"));

        if (Boolean.TRUE.equals(playlist.getExportedToSpotify())) {
            throw new IllegalStateException("Playlist has already been exported to Spotify");
        }

        if (playlist.getTrackUris() == null || playlist.getTrackUris().isEmpty()) {
            throw new IllegalStateException("Playlist has no tracks to export");
        }

        String accessToken = user.getSpotifyAccessToken();
        String spotifyUserId = spotifyService.getCurrentUserId(accessToken);

        String spotifyPlaylistId = spotifyService.createPlaylist(
                accessToken,
                spotifyUserId,
                request.getSpotifyPlaylistName(),
                "Generated by AI"
        );

        spotifyService.addTracksToPlaylist(
                accessToken,
                spotifyPlaylistId,
                playlist.getTrackUris()
        );

        playlist.setExportedToSpotify(true);
        playlist.setSpotifyPlaylistId(spotifyPlaylistId);
        playlistRepository.save(playlist);
    }

    /* =======================
       Playlist queries
       ======================= */

    public List<String> getUserMoods(UUID userId) {
        Pageable topThree = PageRequest.of(0, 3);
        return playlistRepository
                .findDistinctMoodByUserIdOrderByCreatedAtDesc(userId, topThree);
    }

    public long getNumberOfPlaylists(UUID userId) {
        return playlistRepository.countByUserId(userId);
    }

    public List<PlaylistDTO> getUserPlaylists(UUID userId) {
        return playlistRepository.findByUserIdOrderByCreatedAtDesc(userId)
                .stream()
                .map(this::mapToDTO)
                .toList();
    }

    public PlaylistDTO getLastPlaylist(UUID userId) {
        return playlistRepository.findFirstByUserIdOrderByCreatedAtDesc(userId)
                .map(this::mapToDTO)
                .orElse(null);
    }

    public Instant getLastPlaylistTimestamp(UUID userId) {
        return playlistRepository.findLatestTimestamp(userId).orElse(null);
    }

    public List<PlaylistDTO> getPlaylistsByMood(UUID userId, String mood) {
        return playlistRepository.findByUserIdAndMood(userId, mood)
                .stream()
                .map(this::mapToDTO)
                .toList();
    }

    /* =======================
       DTO mapping
       ======================= */

    private PlaylistDTO mapToDTO(Playlist playlist) {
        PlaylistDTO dto = new PlaylistDTO();
        dto.setId(playlist.getId());
        dto.setName(playlist.getName());
        dto.setMood(playlist.getMood());
        dto.setCreatedAt(playlist.getCreatedAt());
        dto.setUserId(playlist.getUserId());

        if (playlist.getSongs() != null) {
            Set<SongDTO> songs = playlist.getSongs()
                    .stream()
                    .map(this::mapToSongDTO)
                    .collect(Collectors.toSet());
            dto.setSongs(songs);
        }

        return dto;
    }

    private SongDTO mapToSongDTO(Song song) {
        return new SongDTO(
                song.getId(),
                song.getName(),
                song.getUrl(),
                song.getArtistName()
        );
    }
}
